# 1.网络七层（OSI）  
***
| OSI层   | 功能 | TCP/IP协议 |
| -------- | -------- | -------- |
| 应用层    | 文件传输，电子邮件，文件服务，虚拟终端    | TFTP/HTTP/SNMP/FTP/SMTP/DNS/Telnet    |
| 表示层    | 数据格式化，代码转换，数据加密     | 无协议     |
| 会话层     | 接触或建立与其他接电的联系    | 无协议   |
| 传输层    | 提供端对端的接口     | TCP/UDP     |
| 网络层   | 为数据包选择路由   | IP/ICMP/RIP/OSPF/BGP/IGMP    |
| 数据链路层  | 传输有地址的桢错误检测功能  | SLIP/CSLIP/PPP/ARP/RARP/MTU    |
| 物理层  | 以二进制数据形式在物理媒体上传播数据  | ISO2110/IEEE802    |  
# 2.TCP/UDP的区别
***
* TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接。
* TCP提供可靠的服务；UDP尽最大努力交付，即不保证可靠交付。
```Tcp通过校验和、重传控制、序号标识、滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制```
* UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
* 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
* TCP对系统资源要求较多，UDP对系统资源要求较少。  

# 3.TCP的三次握手，四次挥手协议
***
* 三次握手
    * 第一次握手：建立连接时,客户端发送syn包(syn=x)到服务器,并进入SYN_SEND状态,等待服务器确认； SYN：同步序列编号
    * 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=x+1）,同时自己也发送一个SYN包（syn=y）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
    * 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手。  
* 四次挥手
    * 第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
    * 第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1，和SYN一样，一个FIN将占用一个序号。
    * 第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
    * 第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1
![](https://github.com/Jiqinglin/Jiqinglin_Data-analysis/raw/master/TCP.jpg)  
# 4.算法
*** 
* 时间复杂度：时间复杂度是指执行算法所需要的计算工作量； 是语句执行次数的数量级。```常见的数量级大小：O(1)＜O(logn)＜O(n)＜O(nlogn)＜O(n2n2)＜O(n3n3)＜O(2n2n)＜O(n!)```
* 空间复杂度：空间复杂度是指执行这个算法所需要的内存空间，是算法所占的存储空间
* 常见算法的时间空间复杂度  
![](https://github.com/Jiqinglin/Jiqinglin_Data-analysis/raw/master/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg)  
* 常见算法的详细信息学习资源  
    * [常见数据结构与算法整理总结（上）]( https://www.jianshu.com/p/230e6fde9c75)  
    * [常见数据结构与算法整理总结（下 ）]( https://www.jianshu.com/p/42f81846c0fb)  
    * [常用数据结构和算法操作效率的对比](https://blog.csdn.net/eson_15/article/details/51952328)  
# 5.箱线图  
* 箱线图也称箱须图，是利用数据中的五个统计量：最小值、第一四分位数、中位数、第三四分位数与最大值来描述数据的一种方法，它也可以粗略地看出数据是否具有有对称性，分布的分散程度等信息，特别可以用于对几个样本的比较。
* 箱线图的功能
    * 直观明了地识别数据批中的异常值
    * 利用箱线图判断数据批的偏态和尾重
    * 利用箱线图比较几批数据的形状  
* 常见的箱线图  
![](https://github.com/Jiqinglin/Jiqinglin_Data-analysis/raw/master/%E7%AE%B1%E7%BA%BF%E5%9B%BE%E5%9B%BE%E7%A4%BA.jpg)  
![](https://github.com/Jiqinglin/Jiqinglin_Data-analysis/raw/master/400px-%E7%AE%B1%E7%BA%BF%E5%9B%BE%E5%9B%BE%E7%A4%BA2.jpg)  
* [箱线图绘制步骤及应用举例](http://wiki.mbalib.com/wiki/%E7%AE%B1%E7%BA%BF%E5%9B%BE)  


# 6.字典的结构是哪种数据结构  
***
* 散列表（哈希表）
也叫哈希表，是根据键（Key）而直接访问在内存存储位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。  
# 7.索引的结构是哪种数据结构
***
B树及其变种B+树  
* B树：
    * 每个节点包含了键值和键值对应的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。
    * 成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。
    * 在B树中查找给定关键字的方法是  
        * 首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。
 
 
* B+树
    * B+树非叶节点中存放的关键码并不指示数据对象的地址指针，只是索引部分。  
    * 所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。  
    * 如果实际数据对象按加入的顺序存储而不是按关键码次数存储，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。
    * B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。
    * B+ 树中，数据对象的插入和删除仅在叶节点上进行。
    * B+树有两种搜索方法：  
        * 按叶节点自己拉起的链表顺序搜索。
        * 从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。  
* 两种索引数据结构的不同之处  
    * B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。  
    * 因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。  
    * B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。  
# 8.索引的介绍
* 优点：
    * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    * 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
    * 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
    * 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
* 缺点：
    * 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
    * 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
    * 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 
* 在哪建：
    * 在经常需要搜索的列上，可以加快搜索的速度；
    * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
    * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
    * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
    * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
    * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。   
# 9.python3和python2的区别  
***  
大致可以分为以下几个方面
* 性能 
* 编码 
* 语法   
* 字符串和字节串   
* 异常   
* 模块变动   

[python2与python3区别详情](http://www.runoob.com/python/python-2x-3x.html)  
# 10.数据挖掘算法和模型  
***
* 数据预处理
* 分类模型
    * 决策树    
    * 贝叶斯分类器   
    * K近邻   
    * 支持向量机   
    * 基于关联规则的分类器   
    * 集成学习   
    * 人工神经网络
* 回归模型
* 预测模型
* 聚类模型 
    * 基于划分的聚类算法   
    * 基于层次的聚类算法   
    * 基于图论的聚类算法    
    * 基于密度的聚类算法  
    * 基于网格的聚类算法  
    * 基于模型的聚类算法    
* 学习资源  
	* [文档参考资料](https://blog.csdn.net/leonis_v/article/details/51658426)  
	
# 11.大数据相关的工具  
***

* <font color=#0099ff  face="黑体">**MongoDB—— 一种流行的，跨平台的面向文档的数据库。**</font>
* Elasticsearch——专为云而构建的分布式REST风格搜索引擎。
* Cassandra——一个开源的分布式数据库管理系统，最初由Facebook开发，被设计用来处理横跨多个商用服务器的大量数据，提供了无单点故障的高度可用性。
* <font color=#0099ff  face="黑体">**Redis—— 一个开源的（BSD许可），内存数据结构存储，作为数据库、缓存和消息代理使用。**</font>
* Hazelcast——基于Java的开源内存数据网格。
* EHCache——一种被广泛使用的开源Java分布式缓存，用于通用缓存、Java EE和轻量级容器。Ehcache相关介绍
* Hadoop——用Java编写的一个开源软件框架，用于分布式存储和对在计算机集群上的超大型数据集的分布式处理。
* Solr——一个开源的企业搜索平台，用Java编写的，来自于Apache Lucene项目。
* <font color=#0099ff  face="黑体">**Spark——Apache Software Foundation中最活跃的项目，一个开源的集群计算框架。**</font>
* Memcached—— 一个通用的分布式内存缓存系统。
* <font color=#0099ff  face="黑体">**Apache Hive——提供了Hadoop之上类似于SQL的层。**</font>
* Apache Kafka—— 一个高通量、分布式的发布-订阅式消息系统，最初开发在LinkedIn上。Windows上脱离Cygwin运行Apache Kafka
* Akka—— 一个工具包和运行时，用于在JVM上构建高度并行的、分布式的、有弹性的消息驱动的应用程序。
* <font color=#0099ff  face="黑体">**HBase—— 一个开源的，非关系型的，分布式数据库，在谷歌的BigTable后建模，用Java编写，并运行在HDFS上。**</font>
* Neo4j——用Java实现的开源图形数据库。
* CouchBase——一个开源的、面向文档的分布式NoSQL数据库，特别为了交互式应用而优化。
* Apache Storm——开源的分布式实时计算系统。
* CouchDB——使用JSON来存储数据的面向文档的开源NoSQL数据库。
* Oracle Coherence—— 一个内存的数据网格解决方案，通过提供快速访问常用数据的渠道，使得企业可预测地扩展关键任务应用程序。
* Titan—— 一个可扩展的图形数据库，优化的目的在于存储和查询包含数千亿顶点和边的图形，分布在多机集群。
* Amazon DynamoDB——一个快速、灵活、完全管理的NoSQL数据库服务，用于在任何规模需要一致的、个位数毫秒延迟的所有应用程序。
* Amazon Kinesis—— 用于在AWS上的流数据的实时平台。  
* 学习资源
	* [视频学习参考资料1](http://study.163.com/course/introduction/1002887002.htm)  
	* [视频学习参考资料2](http://study.163.com/course/introduction/1005031005.htm)
# 12.MySQL测试  
有两个表，一个表名A，有1个字段a，有一组值，且值为1；另一个表名为B，有2个字段，分别是a,b,有两组值，一组为a=0,b=1;另一组为a=1,b=1，请问以下代码的结果是什么
```   
SELECT   
	*
FROM
	A
LEFT JOIN B ON A.a = B.b   
```
![](https://github.com/Jiqinglin/Jiqinglin_Data-analysis/raw/master/MySQL%E6%B5%8B%E8%AF%951.png)  
# 总结  
***
面试技术方面主要考查了一下几点    
* SQL知识```表的连接,索引```
* 网络的基础知识```TCP/IP、三次握手，四次挥手```
* 数据结构和算法知识  ```时间复杂度```
* 大数据相关知识  ```大数据工具、挖掘模型```
* 统计相关知识  ```箱线图```
# 寄语  
***
敬爱的面试官您好    

以上是我关于技术面试的总结，虽然不能在这么短的时间内完全吸收，但是我一定会以这个作为自己的标准去要求自己，努力把所有的都学习到    

我真的真的很想能够到您的手下工作，从今天开始面试，我就觉得您和别的面试官不一样，不是客套，我是真的特别特别希望您能是我的leader，如果我有幸可以到您手下工作，我一定会很努力很努力的工作。   

另外从客观的角度来讲，我觉得我还是有一定的优势的。    

首先：我的SQL还可以，虽然我用MySQL，但是SQL最重要的就是SQL语句，工具只是辅助，我一定会在上岗的时候以最快的速度上手。    

其次：我的python也学了挺久，虽然大型项目我暂时写不了，但小项目我自己写过，比如爬取豆瓣，CSDN，今日头条等网站信息；至少目前读懂程序是没有什么问题的。 


另外：自己最弱的是算法和数据结构的部分，好在我有基础，如果您愿意相信我，我一定会在入职前把这个问题解决掉。  

再者：我的实习时间是3~6个月。如果可以的话我一定会尽我努力留在那，请你相信我一定会是最稳定的实习生。  

至于业务方面，我一定会多加理解，希望能在入职前就能有大概的掌握。

最后就是相关大数据的知识和相关统计知识，我现在正在学习林子雨老师的大数据课程，应该是有帮助的，虽然可能有点赶，但是我能向您保证我一定会最努力最努力的去学习。    

其实说自己的优势无非是想为自己找个借口让您要我，因为我真的很想很想到您那去，我觉得跟着您，我一定可以有所收获，没有套路，真的是特别特别珍惜这次机会，也特别希望您能给我一个机会，薪资什么的真的也不在乎。    

真的是很想为自己再争取一次，我希望您可以看到我的诚意。 如果打扰您了还请您见谅。
